#+TITLE: Vanilla Emacs --> Cade's Emacs

* Packages

** connect package.el with MELPA

  #+begin_src elisp
  (require 'package)
  (add-to-list 'package-archives
    '("melpa" . "https://melpa.org/packages/"))
  (package-initialize)
  (unless package-archive-contents
    (package-refresh-contents))
  #+end_src

** installing use-package

  #+begin_src elisp 
  (unless (package-installed-p 'use-package)
    (package-install 'use-package))
  #+end_src

** Making sure the shell doesn't get messed up

#+begin_src elisp
(use-package exec-path-from-shell :ensure t)
(when (memq window-system '(mac ns x))
  (exec-path-from-shell-initialize))
#+end_src

** Extensible VI Layer

  #+begin_src elisp
  ;; package used for undoing
  (use-package undo-fu :ensure t)
  (use-package evil
      :ensure t ;; install evil if not installed
      :init     ;; tweak evil's configuration before loading
      (setq evil-want-integration t)
      (setq evil-want-keybinding nil)
      (setq evil-vsplit-window-right t)
      (setq evil-split-window-below t)
      (setq evil-undo-system 'undo-fu)
      (evil-mode))
  (use-package evil-collection
    :after evil
    :ensure t
    :config
    (evil-collection-init))
  #+end_src

** General for Key-remaps

  #+begin_src elisp
  (use-package general
     :ensure t
     :config
     (general-evil-setup t))
  #+end_src

** Org-packages

  #+begin_src elisp
    (use-package org-bullets
	:ensure t
	    :init
	    (add-hook 'org-mode-hook (lambda ()
				(org-bullets-mode 1))))
  #+end_src
  
** basic tab block-tag completion

  #+begin_src elisp
  (use-package org-tempo
         :ensure nil)
  #+end_src

** Which Key

  #+begin_src elisp
  (use-package which-key
  :ensure t
  :init
          (setq which-key-side-window-location 'bottom
                  which-key-sort-order #'which-key-key-order-alpha
                  which-key-sort-uppercase-first nil
                  which-key-add-column-padding 1
                  which-key-max-display-columns nil
                  which-key-min-display-lines 6
                  which-key-side-window-slot -10
                  which-key-side-window-max-height 0.25
                  which-key-idle-delay 0.8
                  which-key-max-description-length 25
                  which-key-allow-imprecise-window-fit t
                  which-key-separator " --> " ))
  (which-key-mode)
  #+end_src

** Vertico

#+begin_src elisp
(use-package vertico
 :ensure t
 :init
 (vertico-mode)

  ; Optionally enable cycling for `vertico-next' and `vertico-previous'.
  (setq vertico-cycle t)
)
#+end_src

** V Terminal

  #+begin_src elisp
  (use-package vterm
      :ensure t)
  (setq shell-file-name "/bin/zsh" ;; this will be different for linux and mac machines
      vterm-max-scrollback 5000)
  ;;(setq shell-file-name "/bin/bash" ;; this will be different for linux and mac machines
  ;;    vterm-max-scrollback 5000)
  #+end_src

** Git integration

#+begin_src elisp
(use-package magit :ensure t)
(use-package git-gutter :ensure t :config (global-git-gutter-mode +1))
#+end_src

** File Browser

- testing ztree with some "vimified" keybindings to help with file navigation. The main draw of ztree is its simplicity and that it is 100% elisp.
  #+begin_src elisp
  (use-package ztree :ensure t)
  (general-define-key
   :states '(normal)
   :keymaps 'override
   :prefix "SPC"
   "z" '(ztree-dir :which-key "open ztree directory view"))
  (setq ztree-dir-move-focus t)
  (add-hook 'ztree-mode-hook
            #'(lambda ()
               (local-set-key (kbd "C-c z") #'kill-buffer-and-window)))
  #+end_src

- adding some vim like keymappings

  | H     | goes back in dir tree                           |
  | L     | goes forward in dir tree                        |
  | o     | expands dir / opens a file in horizontal buffer |
  | q     | closes ztree                                    |
  | x     | fully expands all subdirs of current dir        |
  | C-h   | show/ hide hidden files                         |
  | c-z d | open dired at current point in tree             |
- mac os or "darwin" specific dired config
  #+begin_src elisp
(when (string= system-type "darwin")       
  (setq dired-use-ls-dired nil))
  #+end_src 

  #+begin_src elisp
  (general-define-key
   :states '(normal)
   :keymaps 'ztree-mode-map
   "H" 'ztree-dir-widen-to-parent
   "L" 'ztree-dir-narrow-to-dir
   "o" 'ztree-perform-action)
  (define-key ztree-mode-map (kbd "C-h") 'ztree-dir-toggle-show-filtered-files)
  (define-key ztree-mode-map (kbd "C-z d") 'ztree-dir-open-dired-at-point)
  #+end_src

** Language support

*** Flycheck 
- it seems to be a better flymake, if it is too much I will disable 
#+begin_src elisp
(use-package flycheck
  :ensure t
  :init (global-flycheck-mode))
#+end_src

*** LSP-mode

- using lsp-deferred so that only when a buffer is open, this should make startup faster and emacs a bit more performant (i hope)
- I will only be using the LSP with certain languages, for most languages I will try to refrain from using a language server purely to force myself to be a bit more precise while programming
- to add and remove folders use 'C-l -> C-l -> F'
  #+begin_src elisp
  (use-package lsp-mode
    :ensure t
    :hook
    (lsp-mode . lsp-enable-which-key-integration)
    (go-mode . lsp-deferred)
    (js-mode . lsp-deferred)
    (lua-mode . lsp-deferred)
    :commands (lsp lsp-deferred)
    :config
    (define-key lsp-mode-map (kbd "C-l C-l") lsp-command-map))
  #+End_src
- also using lsp-ui to give more of an IDE feel to emacs
  #+begin_src elisp
  (use-package lsp-ui :ensure t)
  #+end_src
- the documentation of what I am using can be found [[https://emacs-lsp.github.io/lsp-mode/page/main-features/][here]]

*** Company-mode

- this mode allows for an autocomplete window to popup as you code
- i had it enabled in all buffers but was not a huge fan of this so I bound it to the vim COC control space keybinding to initialize it 
  #+begin_src elisp
  (use-package company
    :ensure t
    :bind ("C-SPC" . company-mode)
    :config (setq lsp-completion-provider :capf))

  (with-eval-after-load 'company
    (define-key company-active-map (kbd "Tab") nil)
    (define-key company-active-map (kbd "<tab>") nil))
  #+end_src

- Remove the tab function as it conflicts with yas snippet

- the "recommended settings"
  #+begin_src elisp
  (setq company-minimum-prefix-length 1
        company-idle-delay 0.0) ;; default is 0.2
  (setq company-selection-wrap-around t)
  (setq lsp-ui-doc-show-with-cursor nil)
  #+end_src

*** Yas Snippet
- what would and IDE be without some snippets?
- using yas snippet seems to be the best
- enable the global minor mode

  #+begin_src elisp
    (use-package yasnippet :ensure t
      :config
      (setq yas-snippet-dirs '("~/.emacs.d/snips"))
      (yas-global-mode 1))
  #+end_src

- Snippets are just files (no extension) 

*** Projectile
- projectile helps with project management and navigating the project folders.
#+begin_src elisp
(use-package projectile :ensure t)
(projectile-mode +1)
;; Recommended keymap prefix on Windows/Linux
(general-define-key
 :states '(normal)
 :prefix "SPC"
 "p" '(projectile-command-map :which-key "projectile command map")
 "p f" '(projectile-find-file :which-key "projectile find file"))
#+end_src
- Some usefull tips
- Projectile is good about guessing what is in a "project dir" but some of the most telltale are .git's and if you want to force it to see a project you can put a ~.projectile~ file in the main dir of your project.
- 
*** Helm
- helm is a fuzzy finder for emacs
#+begin_src elisp
(use-package helm-lsp :ensure t)
(use-package helm :ensure t
  :config (helm-mode)(require 'helm-config))
(use-package helm-projectile :ensure t :config (helm-projectile-on))
#+end_src
*** Haskell

- getting the base language support
  
#+begin_src elisp
(use-package haskell-mode :ensure t)
(use-package lsp-haskell :ensure t)
(require 'lsp-haskell)
(add-hook 'haskell-mode-hook #'lsp)
(add-hook 'haskell-literate-mode-hook #'lsp)
#+end_src

- interactive haskell support, as detailed [[http://haskell.github.io/haskell-mode/manual/latest/Interactive-Haskell.html#Interactive-Haskell][here]] 
  - C-c C-l will open an interactive buffer /REPL like environment

    #+begin_src elisp
    (require 'haskell-interactive-mode)
    (require 'haskell-process)
    (add-hook 'haskell-mode-hook 'interactive-haskell-mode)
    #+end_src 

  - some "helpful and benign" customizations

    #+begin_src elisp
    (custom-set-variables
      '(haskell-process-suggest-remove-import-lines t)
      '(haskell-process-auto-import-loaded-modules t)
      '(haskell-process-log t))
    #+end_src

  - some "special" keybindings that rely heavily on the space bar 

    #+begin_src elisp
    (general-define-key
     :states '(normal)
     :keymaps 'haskell-mode-map
     :prefix "SPC"
     "c l" '(haskell-process-load-or-reload :which-key "load current file")
     "'" '(haskell-interactive-bring :which-key "interactive bring")
     "c t" '(haskell-process-do-type :which-key "process do type")
     "c i" '(haskell-process-do-info :which-key "process do info")
     "c SPC c" '(haskell-process-cabal-build :which-key "cabal build")
     "c k" '(haskell-interactive-mode-clear :which-key "interactive mode clear")
     "c c" '(haskell-process-cabal :which-key "process cabal"))
    ;; managing imports
    (define-key haskell-mode-map (kbd "<f8>") 'haskell-navigate-imports)
    #+end_src
*** Lua
- using lua mode with the lsp server that was compiled and installed to .emacs.d/.cache/lsp
- some of the helpful commands and more involved instructions can be found on the [[https://emacs-lsp.github.io/lsp-mode/page/lsp-lua-language-server/][emacs-lsp]] website
#+begin_src elisp
(use-package lua-mode :ensure t)
#+end_src
*** GoLang

- Getting go-mode installed
  #+begin_src elisp
  (use-package go-mode :ensure t)
  #+end_src

- some settings promoted by go, allows for auto-formatting on save
  #+begin_src elisp
  (defun lsp-go-install-save-hooks ()
    (add-hook 'before-save-hook #'lsp-format-buffer t t)
    (add-hook 'before-save-hook #'lsp-organize-imports t t))
  (add-hook 'go-mode-hook #'lsp-go-install-save-hooks)
  #+end_src
*** Rust
- Rustic seems to be a very well thought out (and hopefully implemented package) it connects to lsp mode / flycheck and uses rust-analyzer by default.
- I will set these just to be extra specific 
- [[https://github.com/brotzeit/rustic][rustic github]]
#+begin_src elisp
(use-package rustic :ensure t)
(setq rustic-lsp-server 'rust-analyzer)
(setq rustic-lsp-client 'lsp-mode)
#+end_src
*** JS

- everything is installed / initially configured in the lsp-mode note. I will need to add some keybindings as I go. 
*** Java
#+begin_src elisp
(use-package lsp-java :ensure t :config (add-hook 'java-mode-hook #'lsp-deferred))
(use-package dap-mode :ensure t :after lsp-mode :config (dap-auto-configure-mode))
(use-package dap-java :ensure nil)
#+end_src
*** Python
- uses lsp-pyright with the open source pyright server. Using this because it can be used with nvim /emacs.
- the settings of which can be found [[https://emacs-lsp.github.io/lsp-pyright/][here]]. 

#+begin_src elisp
(use-package lsp-pyright
  :ensure t
  :hook (python-mode . (lambda ()
                          (require 'lsp-pyright)
                          (lsp-deferred))))
#+end_src 

*** Scheme(s)

#+begin_src elisp
(use-package geiser-guile :ensure t)
#+end_src

*** Markdown

#+begin_src elisp
(use-package markdown-mode :ensure t :config (add-hook 'markdown-mode-hook 'flyspell-mode))
#+end_src

*** R
- to open an R repl use mx-R, to use lintr you need to install and have a folder ~~/.R/lintr_cache~ otherwise it won't work, if you enable company mode you will get completions aswell.
#+begin_src elisp
(use-package ess :ensure t)
(require 'ess-site)
(setq ess-use-flymake nil)
#+end_src
- for the Rdired buffer I will make a command that should toggle it. p for preview, d for delete, v for view...
#+begin_src elisp
(add-hook 'ess-r-mode-hook
	  #'(lambda ()
	     (local-set-key (kbd "C-c C-r d") #'ess-rdired)))

(add-hook 'ess-rdired-mode-hook
	  #'(lambda ()
	     (local-set-key (kbd "C-c C-r d") #'kill-buffer-and-window)))
;; so I don't have to remap the standard bindings
(evil-set-initial-state 'ess-rdired-mode 'emacs)
#+end_src
- to properly configure r markdown you need the following plugins.
#+begin_src elisp
(use-package poly-markdown :ensure t)
(use-package poly-R :ensure t)
(require 'poly-markdown)
(require 'poly-R)

;; MARKDOWN

(add-to-list 'auto-mode-alist '("\\.md" . poly-markdown-mode))

;; R modes

(add-to-list 'auto-mode-alist '("\\.Snw" . poly-noweb+r-mode))
(add-to-list 'auto-mode-alist '("\\.Rnw" . poly-noweb+r-mode))
(add-to-list 'auto-mode-alist '("\\.Rmd" . poly-markdown+r-mode))

#+end_src

- some usefull commands
  | command | function            |
  |---------+---------------------|
  | C-RET   | eval line           |
  | C-M-x   | eval paragraph      |
  | M-n e   | knit document       |
*** cht.sh
#+begin_src elisp
(add-to-list 'load-path "~/.emacs.d/lisp/")
(load "cheat-sh.el")
#+end_src

* Themes

- getting rid of some junk

  #+begin_src elisp
  (menu-bar-mode 0)
  (tool-bar-mode 0)
  (scroll-bar-mode -1)
  (setq inhibit-splash-screen t)
  (setq make-backup-files nil) 
  (setq auto-save-default nil)
  #+end_src

- adding line numbers

  #+begin_src elisp
  (global-display-line-numbers-mode 1)
  (global-visual-line-mode t)
  (setq display-line-numbers-type 'relative)
  #+end_src 
  
*** Color theme(s)

- adding generic color theme

  #+begin_src elisp
  ;;basic theme that is on every installation
  ;;(load-theme 'wombat t)
  #+end_src

- theme for use with mac os (I theme mac os with Gruvbox)
  
  #+begin_src elisp
  (use-package gruvbox-theme :ensure t)
  (load-theme 'gruvbox-dark-soft t)
  #+end_src

- Retro light theme 
  #+begin_src elisp
  ;;(use-package leuven-theme :ensure t :config (load-theme 'leuven t))
  #+end_src

- theme for use with linux (currently using a nord theme)
  
  #+begin_src elisp
  ;;(use-package nord-theme :ensure t)
  ;;(load-theme 'nord t)
  #+end_src

- a nice dracula theme for tiling window manager setup
  
  #+begin_src elisp
;; (use-package dracula-theme :ensure t)
;; (load-theme 'dracula t)
  #+end_src

*** modeline
#+begin_src elisp
(use-package telephone-line :ensure t)
(telephone-line-mode 1)
#+end_src
*** Font's

- *Font* setup, I am a fan of firacode. It is the best because of how it renders 0's and && symbols (it's not opinion but fact :) )
  - using the all the icons package to make sure that unicode glyphs don't get messed up
  - you have to remember to run ~m-x all-the-icons-install-fonts~ 

  #+begin_src elisp
  (use-package all-the-icons :ensure t)
  (set-face-attribute 'default nil :font "Monoid 12")
  ;;(set-face-attribute 'default nil :font "SauceCode Pro Nerd Fond 14")
  #+end_src

*** Errors & warnings 
  
- getting the error bell sound to go away and just having the mode-line flash

  #+begin_src elisp
  (setq visible-bell nil
        ring-bell-function 'flash-mode-line)
  (defun flash-mode-line ()
    (invert-face 'mode-line)
    (run-with-timer 0.1 nil #'invert-face 'mode-line))
  #+end_src
  
* Org-configuration

** Org Beautification, basics
  
  #+begin_src elisp
    (add-hook 'org-mode-hook 'org-indent-mode)
    (setq org-directory "~/org/"
	  org-hide-emphasis-markers t
	  org-bullets-bullet-list '("●" "○" "◆" "◇"))
    (setq org-src-preserve-indentation nil)
    (use-package htmlize :ensure t) ;; allows for syntax highlighting on exports
  #+end_src

** Code-Block highlighting

    #+begin_src elisp
    (setq org-src-fontify-natively t
        org-src-tab-acts-natively t
        org-confirm-babel-evaluate nil
        org-edit-src-content-indentation 0)
    #+end_src

** Babel Code-Block Configuration

- Scheme configuration
  
#+begin_src elisp
(org-babel-do-load-languages
  'org-babel-load-languages
  '((scheme . t)
   (lua . t)
   (R . t)
   (haskell . t)
   ))
#+end_src

- JS configuration

#+begin_src elisp
(require 'ob-js)
(add-to-list 'org-babel-load-languages '(js . t))
(org-babel-do-load-languages 'org-babel-load-languages org-babel-load-languages)
(add-to-list 'org-babel-tangle-lang-exts '("js" . "js"))
#+end_src

* Key Re-mapping

- *keymaps using General plugin*
- these are non-package related key maps 
  #+begin_src elisp
  (nvmap :states 'normal :keymaps 'override :prefix "SPC"
    "SPC"   '(counsel-M-x :which-key "M-x")
    "c c"   '(compile :which-key "Compile")
    "c C"   '(recompile :which-key "Recompile")
    "h r r" '((lambda () (interactive) (load-file "~/.emacs.d/init.el")) :which-key "Reload emacs config")
    "t t"   '(toggle-truncate-lines :which-key "Toggle truncate lines")
    ;; File manipulation
    "."     '(find-file :which-key "Find file")
    "f s"   '(save-buffer :which-key "Save file")
    "f C"   '(copy-file :which-key "Copy file")
    "f D"   '(delete-file :which-key "Delete file")
    "f R"   '(rename-file :which-key "Rename file")
    ;; Vterm
    "v v"   '(vterm-other-window :which-key "Open Vterm")
    "k k"   '(kill-buffer-and-window :which-key "kill and klose")
    "c h"   '(cheat-sh :which-key "open cheat sheet lookup"))
  #+end_src

**  zooming

#+begin_src elisp
(global-set-key (kbd "C-=") 'text-scale-increase)
(global-set-key (kbd "C--") 'text-scale-decrease)
#+end_src
* Native Comp settings
#+begin_src elisp
(setq warning-minimum-level 'error)
#+end_src
